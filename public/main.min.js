'use strict';

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "html, \nbody {\n    height: 100%;\n    font-size: 16px;\n}\n\n#root {\n    position: relative;\n    width: 50%;\n    padding-top: 2rem;\n    margin: auto;\n}\n\n.node {\n    --node-size: 1rem;\n    \n    position: absolute;\n    width: var(--node-size);\n    height: var(--node-size);\n    border: 1px solid white;\n    transition: background .2s ease-in;\n}\n\n.node[data-blocked=\"true\"] {\n    background: lightgrey;\n}\n\n.node[data-active=\"true\"] {\n    background: green;\n}";
styleInject(css_248z);

class Grid {
    constructor(source) {
        this.isDone = false;
        this.graph = new Map();
        this.fill(source);
        this.start = '0,0';
        this.target = [source[0].length - 1, source.length - 1].toString();
    }
    addNode(node) {
        this.graph.set(node, new Set());
    }
    addEdge(from, to) {
        const fromNode = this.graph.get(from);
        if (fromNode)
            fromNode.add(to);
    }
    addSibling(currentNode, sibling) {
        const siblingNode = String(sibling);
        if (!this.graph.has(siblingNode))
            this.addNode(siblingNode);
        this.addEdge(currentNode, siblingNode);
    }
    fill(matrix) {
        let x = 0;
        while (x < matrix[0].length) {
            let y = 0;
            while (y < matrix.length) {
                const item = matrix[y][x];
                if (item === 0) {
                    const currentNode = [x, y].toString();
                    this.addNode(currentNode);
                    // right
                    if (matrix[y][x + 1] === 0) {
                        this.addSibling(currentNode, [x + 1, y]);
                    }
                    // down
                    if (matrix[y + 1] && matrix[y + 1][x] === 0) {
                        this.addSibling(currentNode, [x, y + 1]);
                    }
                    // left
                    if (matrix[y][x - 1] === 0) {
                        this.addSibling(currentNode, [x - 1, y]);
                    }
                    // up
                    if (matrix[y - 1] && matrix[y - 1][x] === 0) {
                        this.addSibling(currentNode, [x, y - 1]);
                    }
                }
                y++;
            }
            x++;
        }
    }
    dfs(start = this.start, target = this.target, visited = new Set()) {
        if (visited.size === 0)
            this.isDone = false;
        if (this.isDone)
            return;
        visited.add(start);
        const steps = this.graph.get(start);
        if (!steps)
            return;
        for (const step of steps) {
            if (step === target) {
                visited.add(step);
                this.isDone = true;
                return;
            }
            if (!visited.has(step))
                this.dfs(step, target, visited);
        }
        return visited;
    }
    print() {
        for (const node of this.graph.keys()) {
            const siblings = Array.from(this.graph.get(node)).reduce((str, value) => `${str} [${value}]`, '');
            console.log(`[${node}] -> ${siblings}`);
        }
    }
}

const source = [
    [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
];
const grid = new Grid(source);
const path = Array.from(grid.dfs());
// @ts-ignore
const root = document.getElementById('root');
const createNode = ([vX, vY, vZ]) => {
    // @ts-ignore
    const node = document.createElement('div');
    node.className = 'node';
    node.dataset.blocked = Boolean(vZ);
    node.id = `${vX},${vY}`;
    node.setAttribute('style', `top: ${vY}rem; left: ${vX}rem`);
    root.appendChild(node);
};
let x = 0;
while (x < source[0].length) {
    let y = 0;
    while (y < source.length) {
        createNode([x, y, source[y][x]]);
        y++;
    }
    x++;
}
const delay = 100;
path.forEach((id, idx) => {
    setTimeout(() => {
        // @ts-ignore
        const current = document.getElementById(id);
        // @ts-ignore
        const prev = document.getElementById(path[idx - 1]);
        if (prev)
            prev.dataset.active = false;
        current.dataset.active = true;
    }, delay * idx);
});
