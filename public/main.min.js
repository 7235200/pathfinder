'use strict';

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "html, \nbody {\n    height: 100%;\n    font-size: 16px;\n}\n\n#grid {\n    position: relative;\n    margin-top: 1rem;\n}\n\n.node {\n    --node-size: 1rem;\n    \n    position: absolute;\n    width: var(--node-size);\n    height: var(--node-size);\n    border: 1px solid white;\n    transition: background .2s ease-in;\n}\n\n.node[data-blocked=\"true\"] {\n    background: lightgrey;\n}\n\n.node[data-active=\"true\"] {\n    background: red;\n}";
styleInject(css_248z);

class Grid {
    constructor(source) {
        this.isDone = false;
        this.graph = new Map();
        this.fill(source);
        this.start = '0,0';
        this.target = [source[0].length - 1, source.length - 1].toString();
    }
    addNode(node) {
        this.graph.set(node, new Set());
    }
    addEdge(from, to) {
        const fromNode = this.graph.get(from);
        if (fromNode)
            fromNode.add(to);
    }
    addSibling(currentNode, sibling) {
        const siblingNode = String(sibling);
        if (!this.graph.has(siblingNode))
            this.addNode(siblingNode);
        this.addEdge(currentNode, siblingNode);
    }
    fill(matrix) {
        let x = 0;
        while (x < matrix[0].length) {
            let y = 0;
            while (y < matrix.length) {
                const item = matrix[y][x];
                if (item === 0) {
                    const currentNode = [x, y].toString();
                    this.addNode(currentNode);
                    // right
                    if (matrix[y][x + 1] === 0) {
                        this.addSibling(currentNode, [x + 1, y]);
                    }
                    // down
                    if (matrix[y + 1] && matrix[y + 1][x] === 0) {
                        this.addSibling(currentNode, [x, y + 1]);
                    }
                    // left
                    if (matrix[y][x - 1] === 0) {
                        this.addSibling(currentNode, [x - 1, y]);
                    }
                    // up
                    if (matrix[y - 1] && matrix[y - 1][x] === 0) {
                        this.addSibling(currentNode, [x, y - 1]);
                    }
                }
                y++;
            }
            x++;
        }
    }
    dfs(start = this.start, target = this.target, visited = new Set()) {
        if (visited.size === 0)
            this.isDone = false;
        if (this.isDone)
            return;
        visited.add(start);
        const steps = this.graph.get(start);
        if (!steps)
            return;
        for (const step of steps) {
            if (step === target) {
                visited.add(step);
                this.isDone = true;
                return;
            }
            if (!visited.has(step))
                this.dfs(step, target, visited);
        }
        return visited;
    }
    print() {
        for (const node of this.graph.keys()) {
            const siblings = Array.from(this.graph.get(node)).reduce((str, value) => `${str} [${value}]`, '');
            console.log(`[${node}] -> ${siblings}`);
        }
    }
}

const genRow = (size) => {
    return new Array(size).fill(1).map(getRandom);
};
const generateSource = (sWidth, sheight) => {
    const width = sWidth;
    let height = sheight;
    const src = [];
    while (height >= 0) {
        src.push(genRow(width));
        height--;
    }
    src[0][0] = 0;
    src[sheight - 1][sWidth - 1] = 0;
    return src;
};
function getRandom() {
    const num = Math.random();
    if (num < 0.3)
        return 1;
    else
        return 0;
}
// @ts-ignore
const root = document.getElementById('grid');
const createNode = ([vX, vY, vZ]) => {
    // @ts-ignore
    const node = document.createElement('div');
    node.className = 'node';
    node.dataset.blocked = Boolean(vZ);
    node.id = `${vX},${vY}`;
    node.setAttribute('style', `top: ${vY}rem; left: ${vX}rem`);
    root.appendChild(node);
};
let source;
let path;
const draw = () => {
    root.textContent = '';
    source = generateSource(30, 30);
    const grid = new Grid(source);
    path = Array.from(grid.dfs());
    let x = 0;
    while (x < source[0].length) {
        let y = 0;
        while (y < source.length) {
            createNode([x, y, source[y][x]]);
            y++;
        }
        x++;
    }
};
const delay = 85;
const run = () => {
    path.forEach((id, idx) => {
        setTimeout(() => {
            // @ts-ignore
            const current = document.getElementById(id);
            // @ts-ignore
            const prev = document.getElementById(path[idx - 1]);
            if (prev)
                prev.dataset.active = false;
            current.dataset.active = true;
            if (idx === path.length - 1) {
                setTimeout(() => {
                    current.dataset.active = false;
                }, 1000);
            }
        }, delay * idx);
    });
};
// @ts-ignore
const runButton = document.getElementById('run');
// @ts-ignore
const generateButton = document.getElementById('generate');
runButton.onclick = run;
generateButton.onclick = () => {
    draw();
};
